/* Instruction encoding summary:

immmediate 00xx xiii iiii irrr
3-operand  010x xxxb bbaa addd
branch     011x xxoo oooo o___
ld         100a aaoo oooo oddd
st         101a aaoo oooo oddd
ldcr       1100 ccc________ddd
stcr       1101 ccc________ddd
(ext)      1110
syscall    1111 000i iiii i___      Shares constant with `immediate`, top 2 bits are zero
jump abs   1111 001a aa__ _lll
jump       1111 01oo oooo olll
ldp        1111 100a aa__ _ddd
st_cond    1111 101a aa__ _ddd
reti       1111 110_ ____ ____
break      1111 111_ ____ ____

Instruction fields:
these need to be implemented in HW to decode the instructions

0 Opcode           xxxx xxx_ ____ ____
1 Destination reg  ____ ____ ____ _rrr
2 Left bus reg     ____ ____ ____ _rrr
3 Left bus reg     ____ ____ __rr r___
4 Right bus reg    ____ ___r rr__ ____
5 Right bus reg    ___r rr__ ____ ____
6 Control register ____ ccc_ ____ ____
7 Right bus immm   ____ _iii iiii i___
8 Addr offset imm  ____ __ii iiii i___
    - Overlaps with opcode, so that access can be restricted outside kernel mode

*/


{
instructions: {
    // Immediate operations (Prefix 00)
    // ================================
    "addi": {
        title: "Add immediate value to register",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "000", "immediate", "r"],
        pseudocode: "r += immediate",
        microcode: [
            ["f2->left", "f7->right", "alu_add->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },
    "andi": {
        title: "Bitwise and immediate value with register",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "001", "immediate", "r"],
        pseudocode: "r &= immediate",
        microcode: [
            ["f2->left", "f5->right", "alu_and->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },
    "ori": {
        title: "Bitwise or immediate value with register",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "010", "immediate", "r"],
        pseudocode: "r |= immediate",
        microcode: [
            ["f2->left", "f5->right", "alu_or->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },
    "xori": {
        title: "Bitwise xor immediate value with register",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "011", "immediate", "r"],
        pseudocode: "r ^= immediate",
        microcode: [
            ["f2->left", "f5->right", "alu_xor->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },
    "cmpi": {
        title: "Compare immediate value with register",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "100", "immediate", "r"],
        pseudocode: "ignore_value(r - immediate)",
        microcode: [
            ["f2->left", "f5->right", "alu_sub->result", "{next_instruction}", "end_instruction"]
        ]
    },
    "ldi": {
        title: "Load immediate value",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "101", "immediate", "r"],
        pseudocode: "r = immediate",
        microcode: [
            ["zero->left", "f5->right", "alu_or->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },
    "ldui": {
        title: "Load immediate value to high byte",
        args: {"r": "gpr", "immediate": "s8"},
        encoding: ["00", "110", "immediate", "r"],
        pseudocode: "r = immediate << 8",
        microcode: [
            ["zero->left", "f5->right", "alu_upsample->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },
    "addipc": {
        title: "Add immediate value to program counter",
        args: {"rd": "gpr", "immediate": "s8"},
        encoding: ["00", "111", "immediate", "rd"],
        pseudocode: "r = Pc + immediate",
        microcode: [
            ["pc->left", "f5->right", "alu_add->result", "result->f1", "{next_instruction}", "end_instruction"]
        ]
    },

    // 3 operand ALU operations (Prefix 010)
    // ================================
    "add": {
        title: "Add",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0000", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 + rs2",
    },
    "addc": {
        title: "Add with carry",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0001", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 + rs2 + carry",
    },
    "sub": {
        title: "Subtract",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0010", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 - rs2",
    },
    "subc": {
        title: "Subtract with carry",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0011", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 - rs2 - carry",
    },
    "and": {
        title: "Bitwise and",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0100", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 & rs2",
    },
    "or": {
        title: "Bitwise or",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0101", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 | rs2",
    },
    "xor": {
        title: "Bitwise xor",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0110", "rs2", "rs1", "rd"],
        pseudocode: "rd = rs1 ^ rs2",
    },
    "cmp": {
        title: "Compare",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "0111", "rs2", "rs1", "rd"],
        pseudocode: "ignore_value(rs1 - rs2)",
    },
    "hadd": {
        title: "Halving add",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "1000", "rs2", "rs1", "rd"],
        pseudocode: "rd = (rs1 + rs2) >> 1",
    },
    "haddc": {
        title: "Halving add with carry",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "1001", "rs2", "rs1", "rd"],
        pseudocode: "rd = (rs1 + rs2 + carry << 15) >> 1",
        note: [
            "`haddc` operation only sets carry from the least significant side, even though the operation may overflow on both sides! E.g. `haddc(0x8000, 0x8000)` with `carry = 1`, will result in carry not being set."
        ],
    },
    "upsample": {
        title: "Upsample two 8bit values to 16bit",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "1010", "rs1", "rs2", "rd"],
        pseudocode: "rd = (rs1 << 8) | (rs2 & 0xff)",
        note: "Encoding of this instruction has the source registers backwards compared to all other ALU instruction. This is because this functional unit is reused for `ldui` instruction and we need to have the upper byte come from the right bus."
    },
    "byteswap": {
        title: "Swap bytes of words",
        description: "This instruction takes the middle word of the concatenation of the two source words (in big endian): `byteswap(0xaabb, 0xccdd) = 0xbbcc`",
        args: {"rd": "gpr", "rs1": "gpr", "rs2": "gpr"},
        encoding: ["010", "1011", "rs2", "rs1", "rd"],
        pseudocode: "rd = (rs1 << 8) | (rs2 >> 8)",
    },
    // Free opcodes ["010", "1100"] - ["010", "1111"]

    // Branch (Prefix 011)
    // ===========================
    "bz": {
        title: "Branch if zero",
        args: {"offset": "s7"},
        encoding: ["011", "000", "offset", "xxx"],
        pseudocode: "if zero: Pc += offset",
        note: "Branch delay slot",
    },
    "bnz": {
        title: "Branch if not zero",
        args: {"offset": "s7"},
        encoding: ["011", "001", "offset", "xxx"],
        pseudocode: "if !zero: Pc += offset",
        note: "Branch delay slot",
    },
    "bc": {
        title: "Branch if carry",
        args: {"offset": "s7"},
        encoding: ["011", "010", "offset", "xxx"],
        pseudocode: "if carry: Pc += offset",
        note: "Branch delay slot",
    },
    "bnc": {
        title: "Branch if not carry",
        args: {"offset": "s7"},
        encoding: ["011", "011", "offset", "xxx"],
        pseudocode: "if !carry: Pc += offset",
        note: "Branch delay slot",
    },
    "bn": {
        title: "Branch if negative",
        args: {"offset": "s7"},
        encoding: ["011", "100", "offset", "xxx"],
        pseudocode: "if negative: Pc += offset",
        note: "Branch delay slot",
    },
    "bnn": {
        title: "Branch if not negative",
        args: {"offset": "s7"},
        encoding: ["011", "101", "offset", "xxx"],
        pseudocode: "if !negative: Pc += offset",
        note: "Branch delay slot",
    },
    "bo": {
        title: "Branch if overflow",
        args: {"offset": "s7"},
        encoding: ["011", "110", "offset", "xxx"],
        pseudocode: "if overflow: Pc += offset",
        note: "Branch delay slot",
    },
    "bno": {
        title: "Branch if not overflow",
        args: {"offset": "s7"},
        encoding: ["011", "111", "offset", "xxx"],
        pseudocode: "if !overflow: Pc += offset",
        note: "Branch delay slot",
    },

    // Load/ store (Prefix 10)
    // =======================
    "ld": {
        title: "Load from memory",
        args: {"rd": "gpr", "address": "gpr", "offset": "s7"},
        encoding: ["10", "0", "address", "offset", "rd"],
        pseudocode: "rd = memory[address + offset]",
        cycles: 2,
    },
    "st": {
        title: "Store to memory",
        args: {"address": "gpr", "offset": "s7", "rs": "gpr"},
        encoding: ["10", "1", "address", "offset", "rs"],
        pseudocode: "memory[address + offset] = rs",
        cycles: 2,
    },

    // Control registers (Prefix 110)
    // ===============================
    "ldcr": {
        title: "Load from control register",
        args: {"rd": "gpr", "cr": "cr"},
        encoding: ["110", "0", "cr", "xxxxxx", "rd"],
        pseudocode: "rd = cr",
    },
    "stcr": {
        title: "Store to control register",
        args: {"cr": "cr", "rs": "gpr"},
        encoding: ["110", "1", "cr", "xxxxxx", "rs"],
        pseudocode: "cr = rs",
    },

    // Free opcodes ["1110"]

    // Misc (Prefix 1111)
    // ============================
    "syscall": {
        title: "Syscall",
        args: {"code": "u6"},
        encoding: ["1111", "000", "code", "xxx"],
    },
    "ja": {
        title: "Absolute jump with link",
        args: {"address": "gpr", "link": "gpr"},
        encoding: ["1111", "001", "address", "xxx", "link"],
        pseudocode: [
            "link = Pc",
            "Pc = address",
        ],
    },
    "j": {
        title: "Relative jump with link",
        args: {"offset": "s7", "link": "gpr"},
        encoding: ["1111", "01", "offset", "link"],
        pseudocode: [
            "link = Pc",
            "Pc += offset",
        ],
    },
    "ldp": {
        title: "Load from program memory",
        args: {"rd": "gpr", "address": "gpr"},
        encoding: ["1111", "100", "address", "xxx", "rd"],
        pseudocode: "rd = program_memory[address]",
    },
    "st_cond": {
        title: "Store to memory conditional",
        args: {"address": "gpr", "rs": "gpr"},
        description: "Stores a value in memory unless the CPU was interrupted since last load",
        encoding: ["1111", "101", "address", "xxx", "rs"],
        pseudoceode: "if !interrupted: memory[address] = rs",
    },
    "reti": {
        title: "Return from interrupt",
        encoding: ["1111", "110", "xxxxxxxxx"],
    },
    "break": {
        title: "Break",
        encoding: ["1111", "111", "xxxxxxxxx"],
    },
},
"invalid_instruction": {
    title: "Handler for unused / invalid instructions",
    //TODO: microcode
},
/*substitutions: {
    next_instruction: {
       "microcode": ["pc->address", "1->addr_offset", "mem_address->pc", "read->mem_data", "mem_data->instruction"],
    }
}*/
}

