{
instructions: {
    // Binary operations with immediate value (Prefix 000)
    // ================================
    "addi": {
        title: "Add immediate to accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "000", "immediate"],
        pseudocode: "A += immediate",
    },
    "andi": {
        title: "Bitwise and immediate to accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "001", "immediate"],
        pseudocode: "A &= immediate",
    },
    "ori": {
        title: "Bitwise or immediate to accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "010", "immediate"],
        pseudocode: "A |= immediate",
    },
    "xori": {
        title: "Bitwise xor immediate to accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "011", "immediate"],
        pseudocode: "A ^= immediate",
    },
    "cmpi": {
        title: "Compare immediate with accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "100", "immediate"],
        pseudocode: "ignore(A - immediate)",
    },
    "addipc": {
        title: "Add immediate to program counter and store to accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "101", "immediate"],
        pseudocode: "A = Pc + immediate",
    },
    "ldi": {
        title: "Load immediate to accumulator",
        args: {"immediate": "s10"},
        encoding: ["000", "110", "immediate"],
        pseudocode: "A = immediate",
    },
    "ldui": {
        title: "Set upper byte of accumulator from immediate",
        args: {"immediate": "s10"},
        encoding: ["000", "111", "immediate"],
        pseudocode: "A = (A & 0xff) | (immediate << 8)",
    },

    // Binary operations with scratchpad register (Prefix 001)
    // ================================
    "add": {
        title: "Add scratchpad register to accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "0000", "xxxx", "reg"],
        pseudocode: "A += reg",
    },
    "addc": {
        title: "Add scratchpad register to accumulator with carry",
        args: {"reg": "gpr"},
        encoding: ["001", "0001", "xxxx", "reg"],
        pseudocode: "A += reg + C",
    },
    "sub": {
        title: "Subtract scratchpad register from accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "0010", "xxxx", "reg"],
        pseudocode: "A -= reg",
    },
    "subc": {
        title: "Subtract scratchpad register from accumulator with carry",
        args: {"reg": "gpr"},
        encoding: ["001", "0011", "xxxx", "reg"],
        pseudocode: "A -= reg + C",
    },
    "cmp": {
        title: "Compare scratchpad register with accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "0100", "xxxx", "reg"],
        pseudocode: "ignore(A - reg)",
    },
    "and": {
        title: "Bitwise and scratchpad register to accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "0101", "xxxx", "reg"],
        pseudocode: "A &= reg",
    },
    "or": {
        title: "Bitwise or scratchpad register to accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "0110", "xxxx", "reg"],
        pseudocode: "A |= reg",
    },
    "xor": {
        title: "Bitwise xor scratchpad register to accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "0111", "xxxx", "reg"],
        pseudocode: "A ^= reg",
    },
    "set_hi": {
        title: "Set high byte of accumulator from upper byte of scratchpad register",
        args: {"reg": "gpr"},
        encoding: ["001", "1000", "xxxx", "reg"],
        pseudocode: "A = (A & 0xff) | (reg << 8)",
    },
    "from_scratchpad": {
        title: "Copy value from scratchpad register to accumulator",
        args: {"reg": "gpr"},
        encoding: ["001", "1001", "xxxx", "reg"],
        pseudocode: "A = reg",
    },
    "to_scratchpad": {
        title: "Copy value from accumulator to scratchpad register",
        args: {"reg": "gpr"},
        encoding: ["001", "1010", "xxxx", "reg"],
        pseudocode: "reg = A",
    },
    // Free opcodes ["001", "1011"] - ["001", "1111]

    // Unary operations (Prefix 010)
    // ================================
    "neg": {
        title: "Negate accumulator",
        encoding: ["010", "0000", "xxxxxxxxx"],
        pseudocode: "A = -A",
    },

    // Load/ store (Prefix 10)
    // =======================
    "ld": {
        title: "Load",
        args: {"dest": "gpr", "address": "gpr", "offset": "s7"},
        encoding: ["10", "0", "offset", "address", "dest"],
        pseudocode: "dest = [address + offset]",
        microcode: [
            ["f2->right", "right->address", "f6->addr_offset", "read->mem_data", "mem_data->result", "result->f3"],
            ["{next_instruction}", "end_instruction"],
        ]
    },
    "st": {
        title: "Store",
        args: {"address": "gpr", "value": "gpr", "offset": "s7"},
        encoding: ["10", "1", "offset", "address", "value"],
        pseudocode: "[address + offset] = value",
        microcode: [
            ["f3->left", "left->mem_data", "f2->right", "right->address", "f6->addr_offset", "mem_write"],
            ["{next_instruction}", "end_instruction"],
        ]
    },

    // Jumps (Prefix 110)
    // ===========================
    "jmp{condition}": {
        title: "Absolute jump {condition}",
        args: {"address": "gpr"},
        encoding: ["110", "0", "{condition}", "xxx", "address", "xxx"],
        pseudocode: "if {condition}: Pc = address",
        microcode: [
            ["?{condition}", "f2->right", "right->address", "0->addr_offset", "mem_address->pc", "read->mem_data", "mem_data->instruction", "end_instruction"],
            ["?!{condition}", "{next_instruction}", "end_instruction"]
        ],
        cycles: 1
    },
    "rjmp{condition}": {
        title: "Relative jump {condition}",
        args: {"jump_offset": "s9"},
        encoding: ["110", "1", "{condition}", "jump_offset"],
        pseudocode: "if {condition}: Pc += jump_offset",
        microcode: [
            ["?{condition}", "pc->address", "f7->addr_offset", "mem_address->pc", "read->mem_data", "mem_data->instruction", "end_instruction"],
            ["?!{condition}", "{next_instruction}", "end_instruction"]
        ]
        cycles: 1
    },

    // Control registers (Prefix 1110)
    // ===============================
    "ldcr": {
        title: "Load from control register",
        args: {"a": "gpr", "cr": "cr"},
        encoding: ["1110", "0", "cr", "xxxxx", "a"],
        pseudocode: "a = cr",
        cycles: 1
    },
    "stcr": {
        title: "Store to control register",
        args: {"cr": "cr", "a": "gpr"},
        encoding: ["1110", "1", "cr", "xxxxx", "a"],
        pseudocode: "cr = a",
        cycles: 1
    },
    /*
    "crpush": {
        title: "crpush",
        args: {"cr": "cr", "r": "gpr"},
        encoding: ["01", "10100", "cr", "xxxxx", "r"],
        pseudocode: [
            "[cr] = r",
            "r = cr"
        ],
        microcode: [
            ["f3->left", "left->mem_data", "f4->right", "right->address", "0->addr_offset", "mem_write"],
            ["f4->right", "0->left", "alu_or->result", "result->f3", "{next_instruction}", "end_instruction"],
        ]
    },
    "crpop": {
        title: "crpop",
        args: {"cr": "cr", "r": "gpr"},
        encoding: ["01", "10100", "cr", "xxxxx", "r"],
        pseudocode: [
            "[cr] = r",
            "r = cr"
        ],
        microcode: [
            ["f3->left", "left->mem_data", "f4->right", "right->address", "0->addr_offset", "mem_write"],
            ["f4->right", "0->left", "alu_or->result", "result->f3", "{next_instruction}", "end_instruction"],
        ]
    },
    */

    // System (Prefix 1111)
    // ============================
    "syscall": {
        title: "Syscall",
        args: {"code": "u6"},
        encoding: ["1111", "000", "code", "xxx"],
        cycles: "TODO",
        note: "Uses the 9bit immediate (field 5), overlapping with zero bits from opcode."
    },
    "reti": {
        title: "Return from interrupt",
        encoding: ["1111", "001", "xxxxxxxxx"],
        pseudocode: [
            "Pc = IntPc",
            "apply ContextID",
        ],
        cycles: "TODO"
    },
    /* Free opcodes ["1111", "010"] - ["1111", "110"] */
    "break": {
        title: "Break",
        encoding: ["1111", "111", "xxxxxxxxx"],
        cycles: 1
    },
},
substitutions: {
    condition: {
        "": {
            title: "unconditional",
            encoding: "000",
            microcode: "true"
        },
        "?z": {
            title: "if zero",
            encoding: "001",
            microcode: "zero",
        },
        "?c": {
            title: "if carry",
            encoding: "010",
            microcode: "carry"
        },
        "?n": {
            title: "if negative",
            encoding: "011",
            microcode: "negative"
        },
        /* Unused condition "100" */
        "?nz": {
            title: "if not zero",
            encoding: "101",
            microcode: "!zero"
        },
        "?nc": {
            title: "if not carry",
            encoding: "110",
            microcode: "!carry"
        },
        "?nn": {
            title: "if not negative",
            encoding: "111",
            microcode: "!negative"
        },
    },
    next_instruction: {
        "microcode": ["pc->address", "1->addr_offset", "mem_address->pc", "read->mem_data", "mem_data->instruction"],
    }
}
}

