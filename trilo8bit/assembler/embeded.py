""" Module implementing trilo8bit assembler embeding in python. """

import pathlib
import inspect

import sys
import os

from .. import isa

class _Value:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return self.name
    def __str__(self):
        return repr(self)


class _Dec:
    """ Pre-decremented 16bit register value """
    def __init__(self, reg):
        self.reg = reg

    def __repr__(self):
        return repr(self.reg) + ".dec"

    def __str__(self):
        return repr(self)


class _Inc:
    """ Post-increment 16bit register value """
    def __init__(self, reg):
        self.reg = reg

    def __repr__(self):
        return repr(self.reg) + ".inc"

    def __str__(self):
        return repr(self)


class _Neg:
    """ Negate condition """
    def __init__(self, reg):
        self.reg = reg

    def __repr__(self):
        return "not " + repr(self.reg)

    def __str__(self):
        return repr(self)


class _16bitRegister(_Value):
    """ 16bit register """


class _8bitRegister(_Value):
    """ 8bit register """
    def __init__(self, i):
        self.i = i
        super().__init__("R{}".format(i))

    @property
    def dec(self):
        """ Pre-decrement the register's value """
        return _Dec(self)

    @property
    def inc(self):
        """ Post-increment the register's value """
        return _Inc(self)


class _1bitRegister(_Value):
    """ Status register item """

    def __not__(self):
        return _Neg(self)

class Embeding:
    """ Members of an instance of this class get injected into the global namespace
    of assembler source files.
    Members that start with underscore and are not all uppercase are considered private.
    Instruction methods are autogenerated from isa. """

    R0 = _8bitRegister(0)
    R1 = _8bitRegister(1)
    R2 = _8bitRegister(2)
    R3 = _8bitRegister(3)
    R4 = _8bitRegister(4)
    Pc = _16bitRegister("Pc")
    Sp = _16bitRegister("Sp")
    Int = _16bitRegister("Int")
    Z = _1bitRegister("Z")
    C = _1bitRegister("C")
    N = _1bitRegister("N")

    _gp_registers= [R0, R1, R2, R3, R4]
    _regpairs = [Pc, R1, R3, Sp]
    _conditions = [C, Z, N]

    def __init__(self, assembler):
        self._assembler = assembler

    def _data(self, data, bits, identifier):
        """ Internal implementation of _DATA and _DATAF.
        data can either be bytes or int. """

        if bits % 8 != 0:
            raise ValueError("Bits must be divisible by 8")
        size = bits // 8
        if size & (size - 1) != 1:
            raise ValueError("Byte size must be a power of 2")

        label = self._assembler.add_label(identifier)
        for data in data:
            if isinstance(data, int):
                self._assembler.add_data(self._assembler.encode_number(data, size))
            else:
                self._assembler.add_data(data)

        return label

    @staticmethod
    def _resolve_path(path, depth):
        """ Return path made relative to a filename corresponding to the frame `depth` above the caller of this method. """
        path = pathlib.Path(path)
        if not path.is_absolute():
            caller_path = inspect.stack(context=0)[depth + 1].filename
            caller_dir = pathlib.Path(caller_path).parent
            path = caller_dir / path

        return path.resolve()

    @staticmethod
    def _arg_error(v, t):
        return ValueError("{} is not a valid argument of type {} (must be one of {})".format(
            repr(v),
            isa.arg_types[t][1],
            ", ".join(s for s in isa.arg_types[t][0] if len(s))
        ))

    def _parse_r(self, v):
        try:
            return (self._gp_registers.index(v), None)
        except ValueError:
            raise self._arg_error(v, "r") from None

    def _parse_a(self, v):
        try:
            return (self._gp_registers.index(v), None)
        except ValueError:
            pass

        if isinstance(v, int):
            return (12, v & 0xff)

        if not isinstance(v, list) or len(v) != 1:
            raise self._arg_error(v, "a") from None

        try:
            i = self._regpairs.index(v[0])
        except ValueError:
            pass
        else:
            if i == 0:
                raise self._arg_error(v, "r") from None
            else:
                return (8 + i, None)

        if not isinstance(_Inc, v[0]):
            raise self._arg_error(v, "r") from None

        try:
            return (12 + self._regpairs.index(v[0].reg), None)
        except ValueError:
            pass

        raise self._arg_error(v, "r") from None

    def _parse_p(self, v):
        try:
            return (self._regpairs.index(v), None)
        except ValueError:
            raise self._arg_error(v, "p") from None

    def _parse_q(self, v):
        try:
            return (self._regpairs.index(v), None)
        except ValueError:
            raise self._arg_error(v, "q") from None

    def _parse_c(self, v):
        if isinstance(bool, v):
            return ((0 if v else 1), None)

        if isinstance(_Neg, v):
            unwrapped = v.reg
            negative = 1
        else:
            unwrapped = v
            negative = 0

        try:
            return (2 * self._conditions.index(unwrapped) + 2 + negative, None)
        except ValueError:
            pass

        raise self._arg_error(v, "c") from None

    def _parse_i(self, v):
        return (0, v & 0xff)

    def _add_instruction(self, mnemonic, *args):
        instruction = self._encode_instruction(mnemonic, args)

        immediate_arg = None
        for arg in args:
            if arg[1] is None:
                continue
            assert immediate_arg is None, "Two instructions that allow immediate argument. This looks like an error in isa."
            immediate_arg = arg[1]

        if next_byte is None:
            self._assembler.add_data(bytes(instruction))
        else:
            self._assembler.add_data(bytes(instruction, immediate_arg))

    def _(self, identifier=None):
        """ Label pseudo-instruction.
        Inserts a label into the assembler program.
        identifier can be any python object that can be used as a key to a dictionary or None,
        in which case an unique identifier is auto-generated.
        The identifier used is returned by this function. """
        if identifier is None:
            identifier = object()
        # TODO!
        return identifier

    def _DATA(self, *data, bits=8, identifier=None, encoding="utf-8"):
        """ Include data in the output.
        `*data` can contain numbers which will be encoded to `bits` wide and stored,
        strings that will be encoded with the chosen encoding and stored
        or bytes that will be stored directly.
        It is an error if string after encoding or bytes has a size that is not a multiple of `bits / 8`.
        `bits` must be divisible by 8.
        `identifier` is an optional identifier of the data. If empty, then an unique one is generated. See function `_` for details.
        The used label is returned from this function. """

        processed_data = []
        for d in data:
            if isinstance(d, bytes) or isinstance(d, int):
                processed_data.append(d)
            elif isinstance(d, str):
                processed_data.append(d.encode(encoding))
            else:
                raise TypeError("Data must be either bytes, str, or int")
        return self._data(processed_data, bits, identifier)

    def _DATAFILE(self, *paths, bits=8, identifier=None):
        """ Include content of data files in the output.
        `*paths` contains names of files (absolute or relative to the current file's path) that will be stored in the output.
        It is an error if the file has a size that is not a multiple of `bits / 8`.
        `bits` must be divisible by 8.
        `identifier` is an optional identifier of the data. If empty, then an unique one is generated. See function `_` for details.
        The used label is returned from this function. """

        return self._data([self._resolve_path(path, depth=1).read_bytes() for path in paths],
                          bits, identifier)

    def _INCLUDE(self, filename):
        """ Include pseudo-instruction.
        TBD """
        pass

    def PUSH(self, value):
        self.ST([self.Sp.dec], value)

    def POP(self, target):
        self.MOV(target, [self.Sp.inc])

    def JMP(self, address):
        self.MOVW(self.Pc, address)

    def _generate_instruction_func_parts(mnemonic, encoding, args, description):
        """ Yield blocks of python code to be eval'd to build up generated instruction methods. """

        yield "def "
        yield mnemonic
        yield "(self"
        for arg in args:
            yield ", "
            yield arg[0]
        yield "):\n"
        yield '    """'
        yield mnemonic
        yield " instruction.\n    "
        yield mnemonic
        yield "("
        yield ", ".join(arg[0] for arg in args)
        yield ") => "
        yield description
        yield '\n    (Instruction method auto generated based on ISA)"""\n'
        yield '    '
        yield 'self._add_instruction("'
        yield mnemonic
        yield '"'
        for arg in args:
            yield ", "
            yield "self._parse_"
            yield arg[1]
            yield "("
            yield arg[0]
            yield ")"
        yield ")"

    for mnemonic, (encoding, args, description) in isa.instructions.items():
        to_exec = "".join(_generate_instruction_func_parts(mnemonic, encoding, args, description))
        #print(to_exec)
        exec(to_exec)
